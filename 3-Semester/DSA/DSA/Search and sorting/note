 Basic Concepts:
1. Sorting:
Sorting is the process of arranging elements in a specific order, typically in ascending or descending order.
The primary goal is to make data retrieval and searching more efficient.
2. Searching:
Searching is the process of finding a specific element in a collection of elements.
Different algorithms are used based on the characteristics of the data, especially whether it's sorted or not.
3. Internal Sorting:
Sorting of data that fits entirely within the computer's main memory.
Algorithms like Bubble Sort, Insertion Sort, Selection Sort, Quick Sort, Shell Sort, Heap Sort, Merge Sort, and Counting Sort are often used for internal sorting.
4. External Sorting:
Sorting of data that is too large to fit into the computer's main memory.
External sorting algorithms are designed to efficiently handle data stored on external storage devices like hard drives.
5. Stable Sorting:
A sorting algorithm is stable if the relative order of equal elements is preserved after sorting.
6. Unstable Sorting:
A sorting algorithm is unstable if the relative order of equal elements may change after sorting.
Sorting Algorithms:
1. Bubble Sort:
Algorithm:
Compare adjacent elements.
Swap them if they are in the wrong order.
Repeat until no more swaps are needed.
2. Insertion Sort:
Algorithm:
Build the final sorted array one element at a time.
Insert each element into its correct position within the sorted portion of the array.
3. Selection Sort:
Algorithm:
Divide the list into a sorted and an unsorted region.
Find the minimum element in the unsorted region and swap it with the first element of the unsorted region.
Expand the sorted region.
4. Quick Sort:
Algorithm:
Choose a pivot element.
Partition the array around the pivot.
Recursively apply quicksort to the two sub-arrays.
5. Shell Sort:
Algorithm:
Choose a gap sequence.
Start with the elements that are 'gap' apart and sort the sub-array.
Reduce the gap and repeat until the gap is 1.
6. Heap Sort:
Algorithm:
Build a max heap from the input data.
Swap the root (maximum element) with the last element.
Reduce the size of the heap and heapify the root.
Repeat until the heap is empty.
7. Merge Sort:
Algorithm:
Divide the unsorted list into n sub-lists.
Recursively apply mergesort to each sub-list.
Merge the sorted sub-lists until only one sub-list remains.
8. Counting Sort:
Algorithm:
Find the range of input elements.
Count the occurrences of each element.
Update the count array to represent the position of each element.
Build the sorted array.
Searching Algorithms:
1. Linear Search:
Algorithm:
Start from the beginning of the list.
Compare the target element with the current element.
If a match is found, return the index; otherwise, move to the next element.
Repeat until the end of the list.
2. Binary Search:
Algorithm:
Compare the target value with the middle element.
If equal, return the index.
If the target is less than the middle element, search in the left half.
If the target is greater, search in the right half.
Repeat until the target is found or the search interval is empty.
Understanding these concepts and algorithms is crucial for designing efficient solutions to sorting and searching problems. The choice of algorithm depends on factors such as data size, structure, and whether the data is sorted or not.
